#!/bin/bash
#
# push-to-pantheon.sh
#
# This script will push all of the generated build results created on a
# CI server such as Travis or Circle to a Drupal site hosted on Pantheon.
#
# This script may be called on the CI server, or locally. On the CI server,
# environment variables are used to authenticate with Pantheon.  When used
# locally, the script assumes that the user has already authenticated with
# terminus before calling this script. The environment variables may also
# be used locally, of course, but this is generally less convenient.
#
# This script will look for and parse a behat-pantheon.yml file to determine
# which Pantheon site to copy to.
#
# The specific environment variables we need are:
#
#   SITE_NAME:     The human-readable name of the site to give to site-install.
#                  Optional. Defaults to $TRAVIS_SITE.
#   MACHINE_TOKEN: The machine token associated with the Pantheon account.
#                  Optional.
#   SITEPASS:      The password that should be set on the test site.
#                  Optional. Defaults to a random string (use `drush uli`).
#   CI_BOT_EMAIL:  The email address to use in the git commit attribution
#   CI_BOT_NAME:   The name to use in the git commit attribution
#   DRUSH_VERSION: The version of Drush to use on Pantheon.
#                  Optional. Defaults to Drush 8.
#
# It is also expected that there should be an SSH private key in
# $HOME/.ssh that can be used to push code to the Pantheon git repository.
#

SELF_DIRNAME="`dirname -- "$0"`"
source $SELF_DIRNAME/setup-environment

echo "Push to Pantheon"

# If Terminus is not already in the $PATH, then we will install it later.
CHECK_TERMINUS="$(which terminus)"

# Check to see if we are already logged on via Terminus (but only if Terminus is installed).
LOGGED_IN=0
if [ -n "$CHECK_TERMINUS" ]
then
  terminus auth:whoami >/dev/null 2>&1
  terminus auth:whoami
  [ $? == 0 ] && LOGGED_IN=1
fi

# Do not attempt to push the site up to Pantheon unless the MACHINE_TOKEN
# environment variable is set.  If we receive a PR from an external
# repository, then the secure environment variables will not be set;
# if we test PRs, we cannot send them to Pantheon in this instance.
# We will allow this to run if the user has already logged in, though.
if [ -n "$MACHINE_TOKEN" ] || [ $LOGGED_IN == 1 ]
then
  echo "Pantheon host checking"
  # Dynamic hosts through Pantheon mean constantly checking interactively
  # that we mean to connect to an unknown host. We ignore those here.
  echo "Turn off strict checking"
  mkdir -p "$HOME/.ssh" && echo "StrictHostKeyChecking no" >> "$HOME/.ssh/config"

  # We need to clear the local Drush cache after defining a new policy file
  echo "Run drush cc drush"
  $PROJECT_BASE_DIR/vendor/bin/drush cc drush

  # Capture the commit message
  export CI_COMMIT_MSG="$(git log --format=%B --no-merges -n 1)"

  # If Terminus is not already in the $PATH, then install it.
  if [ -z "$CHECK_TERMINUS" ]
  then
    echo "Install terminus"
    mkdir -p $HOME/terminus/plugins
    TERMINUS_PLUGINS_DIR=$HOME/terminus/plugins
    composer -n --working-dir=$HOME/terminus require pantheon-systems/terminus:^2
    composer -n --working-dir=$HOME/terminus/plugins require pantheon-systems/terminus-build-tools-plugin:^2.0.0-beta12
  fi

  if [ $LOGGED_IN == 0 ]
  then
    # Set up Terminus, and wake up the site
    echo "Log in to Pantheon via Terminus"
    # Redirect output when logging in.  Terminus prints the email address
    # used during login to stdout, which will end up in the log.  It's better
    # to conceal the email address used, to make it harder for a third party
    # to try to log in via a brute-force password-guessing attack.
    terminus auth:login --machine-token=$MACHINE_TOKEN >/dev/null 2>&1
    check "Logged in to Pantheon via Terminus" "Could not log in to Pantheon with Terminus"
  fi
  echo "Check to see if Pantheon site $TRAVIS_SITE exists"
  mkdir -p "$HOME/.drush"
  which terminus
  PUUID=$(terminus site:info "$TRAVIS_SITE" --field=id 2>/dev/null)
  if [ -z "$PUUID" ] && [ -n $AUTOCREATE ]
  then
    echo "Creating site $TRAVIS_SITE"
    terminus site:create $TRAVIS_SITE $_SITE_NAME empty
    check "Created site $TRAVIS_SITE" "Could not create site $TRAVIS_SITE"
    PUUID=$(terminus site info --site="$TRAVIS_SITE" --field=id 2>/dev/null)
  fi
  if [ -z "$PUUID" ]
  then
    echo "Could not get UUID for $TRAVIS_SITE"
    exit 1
  fi
  PUUID=$(echo $PUUID | sed -e 's/^[^:]*: *//')
  echo "UUID for $TRAVIS_SITE is $PUUID"
  echo "Wake up the site $TRAVIS_SITE"
  terminus env:wake "$TRAVIS_SITE"."$TRAVIS_ENV"
  check "Site wakeup successful" "Could not wake up site"

  # Make sure we are in git mode
  terminus connection:set "$TRAVIS_SITE"."$TRAVIS_ENV" git
  check "Changed connection mode to 'git' for $TRAVIS_SITE $TRAVIS_ENV environment" "Could not change connection mode to 'git' for $TRAVIS_SITE $TRAVIS_ENV environment"

  # Identify the automation user
  if [ -n "$CI" ]
  then
    git config --global user.email "$_CI_BOT_EMAIL"
    git config --global user.name "$_CI_BOT_NAME"
  fi

  # Use the 'master' branch for the dev environment; for multidev,
  # use the branch with the same name as the multidev environment name.
  BRANCH=master
  if [ "$TRAVIS_ENV" != "dev" ]
  then
    BRANCH="$TRAVIS_ENV"
  fi

  # Clone the Pantheon repository into a separate directory, then
  # move the .git file to the location where we placed our composer targets
  cd $PROJECT_BASE_DIR
  REPO="ssh://codeserver.dev.$PUUID@codeserver.dev.$PUUID.drush.in:2222/~/repository.git"
  mkdir -p "$(basename $WORK_REPO)"
  rm -rf "$WORK_REPO"
  git clone --depth 1 --branch "$BRANCH" "$REPO" "$WORK_REPO" >> $HOME/git-clone.log
  check "git clone successful" "Could not clone repository from $REPO"

  # Get rid of any .git directories created by composer
  # Update .gitignore
  composer run prepare-for-pantheon
  rm -rf "$DRUPAL_ROOT/.git"
  # Move the .git directory we checked out on top of the files we built.
  # This is functionally equivalent to copying the built files over the
  # checked-out repository, except more efficient.
  mv "$WORK_REPO/.git" "$DRUPAL_ROOT"

  # Use our .gitignore file from our source repository to build
  # a .gitattributes file in our Pantheon repository.  Anything
  # inside of 'drupal' that is ignored in the source repository is
  # ignored because it is a built target.  We want to also ignore
  # the same set of files when making diffs on the Pantheon repository,
  # to avoid large diffs full of uninteresting changes.
  if [ ! -f "$DRUPAL_ROOT/.gitattributes" ]
  then
    grep drupal $PROJECT_BASE_DIR/.gitignore | sed -e 's#drupal/\(.*\)#\1 -diff#' -e 's#/ -diff#/** -diff#' > "$DRUPAL_ROOT/.gitattributes"
  fi

  # Output of the diff vs upstream.
  cd "$DRUPAL_ROOT"
  # Always ensure we have Pantheon's specific settings in our build before commit
  if [ ! -f "$WORK_REPO/web/sites/default/settings.pantheon.php" ]
  then
    echo "Copying pre-built Pantheon settings files."
    cp config/pantheon/settings.php $DRUPAL_ROOT/web/sites/default/settings.php
    cp config/pantheon/settings.pantheon.php $DRUPAL_ROOT/web/sites/default/settings.pantheon.php
    cp config/pantheon/services.pantheon.preproduction.yml $DRUPAL_ROOT/web/sites/default/services.pantheon.preproduction.yml
  else
    echo "Copying existing Pantheon settings files."
    cp $WORK_REPO/web/sites/default/settings.php $DRUPAL_ROOT/web/sites/default/settings.php
    cp $WORK_REPO/web/sites/default/settings.pantheon.php $DRUPAL_ROOT/web/sites/default/settings.pantheon.php
    cp $WORK_REPO/web/sites/default/services.pantheon.preproduction.yml $DRUPAL_ROOT/web/sites/default/services.pantheon.preproduction.yml
  fi

  echo "Log the status change"
  git status

  echo "Run git commands"
  # Push our built files up to Pantheon
  git add --all >> $HOME/git-add.log
  # Force commit our build theme layer artifacts in /dist for deployments
  git add -f $DRUPAL_ROOT/web/themes/custom/nypl_emulsify/dist
  aborterr "'git add --all' failed"
  git commit -a -m "Built by CI: '$CI_COMMIT_MSG'" >> $HOME/git-commit.txt
  aborterr "'git commit' failed"

  # Create a multidev environment if this is a pull request
  # Push code to master if not a pull request
  if [ -z "$TRAVIS_PULL_REQUEST" ] || [ "$TRAVIS_PULL_REQUEST" != "false" ]
  then
    # Create a new multidev environment (or push to an existing one)
    echo "Creating a multidev environment from $TRAVIS_SITE.dev for env: $TRAVIS_ENV."
    terminus -n build:env:create "$TRAVIS_SITE.dev" "$TRAVIS_ENV" --yes
  else
      # Push to the dev environment
    echo "Pushing code to $TRAVIS_SITE.dev."
    terminus -n build:env:push "$TRAVIS_SITE.dev" --yes
  fi

  terminus drush $TRAVIS_SITE.$TRAVIS_ENV -- updatedb -y
else
  echo "Failed to deploy. Ensure you have a MACHINE_TOKEN configured."
fi
